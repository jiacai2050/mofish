[{"time":1767479014,"type":"story","descendants":324,"title":"Total monthly number of StackOverflow questions over time","id":46482345,"score":583,"url":"https://data.stackexchange.com/stackoverflow/query/1926661#graph","by":"maartin0","summary":"https://data.stackexchange.com/stackoverflow/query/1926661#graph"},{"time":1767457210,"type":"story","descendants":91,"title":"The Most Popular Blogs of Hacker News in 2025","id":46478377,"score":425,"url":"https://refactoringenglish.com/blog/2025-hn-top-5/","by":"mtlynch","summary":"## 2025年Hacker News最受欢迎博主总结\n\n本文总结了2025年Hacker News上最受欢迎的五位博主，并简要介绍了其他值得关注的博主。\n\n**#1 西蒙·威利森 (Simon Willison)**\n\n西蒙·威利森连续第三年成为Hacker News上最受欢迎的博主。他专注于人工智能（AI）领域的写作，在AI成为热门话题的背景下，其受欢迎程度尤为突出。西蒙的特点在于他以用户而非销售者的身份探讨AI工具，对不同厂商的工具保持中立。他经常将TikTok、Twitter等平台上的内容带到Hacker News，引发讨论。西蒙在2025年发表了超过1000篇博文，并强调分享带有评论的链接是一种低成本、高价值的贡献方式。\n\n**#2 杰夫·吉尔林 (Jeff Geerling)**\n\n杰夫·吉尔林取得了他在Hacker News上最成功的年份，排名跃升至第二。他在YouTube上拥有超过100万订阅者，内容涵盖了树莓派电脑、自托管软件和电脑硬件等Hacker News用户感兴趣的主题。为了在Hacker News上取得成功，他会为视频发布配以博文，并注重文章的结构和内容，使其独立于视频存在。\n\n**#3 肖恩·戈德克 (Sean Goedecke)**\n\n肖恩·戈德克在2025年异军突起，成为Hacker News上的博客新星。他曾于2020年间零星地进行博客写作，但在2024年底凭借一篇关于“如何在大型科技公司发布项目”的文章获得了关注。此后，他将发布频率提高到每周多次。肖恩是GitHub的资深软件工程师，他的写作策略是表达与技术行业相关且许多人不同意的观点，并擅长向工程师解释大型科技公司的组织政治。\n\n**#4 布赖恩·克雷布斯 (Brian Krebs)**\n\n布赖恩·克雷布斯是一位独立的调查记者，专注于网络犯罪报道。他是Hacker News上最受欢迎的博主之一，仅次于Hacker News的创始人保罗·格雷厄姆。2025年，他继续关注网络安全领域，并发表了关于特朗普政府试图破坏美国言论自由的文章，该文章一度登上首页，但随后因被大量用户标记而下架。\n\n**#5 尼尔·阿加瓦尔 (Neal Agarwal)**\n\n尼尔·阿加瓦尔的作品更像是互动艺术而非传统的博客文章，包含对网络进行戏仿的游戏和视觉论文。2025年是他在Hacker News上最成功的年份，所有发布的都登上首页，其中约一半达到了#1位置。 他的作品“Stimulation Clicker”是全年第四受欢迎的帖子。\n\n**其他值得关注的博主:**\n\n*   **约翰·格鲁伯 (John Gruber):** 尽管曾公开质疑Hacker News是否对其博客进行了暗中限制，但他在Hacker News上的表现仍然出色，是自2011年以来最佳成绩，并重返前10名。\n*   **马哈德·卡拉姆 (Mahad Kalam):** 仅凭一篇关于Slack的博客文章就获得了#21的排名，该文章也成为年度最受欢迎的帖子之一。\n*   **布赖恩·黄 (Bryan Huang):** 同样仅凭一篇博客文章，排名紧随马哈德·卡拉姆之后，该文章也成为年度第三受欢迎的帖子。\n\n总而言之，2025年Hacker News上的博主们涵盖了广泛的主题，展现了技术、安全、艺术和观点分享的多样性。"},{"time":1767502936,"type":"story","descendants":32,"title":"Neural Networks: Zero to Hero","id":46485090,"score":415,"url":"https://karpathy.ai/zero-to-hero.html","by":"suioir","summary":"## Andrej Karpathy 的神经网络构建课程总结 (Summary of Andrej Karpathy's Neural Network Building Course)\n\n这是一门由 Andrej Karpathy 教授的课程，旨在从零开始用代码构建神经网络，最终目标是实现类似 GPT 的现代深度神经网络。课程强调语言模型作为学习深度学习的优秀切入点，因为所学知识可以广泛应用于其他领域，如计算机视觉。\n\n**先决条件:** 扎实的 Python 编程基础，以及基本的数学知识 (例如导数、高斯分布)。\n\n**课程大纲 (Syllabus):**\n\n课程总时长约 2h25m，以循序渐进的方式讲解反向传播和神经网络训练的基础知识。\n\n* **第一部分 (1h57m):** 实现一个基于大格的字符级语言模型，为后续构建现代 Transformer 语言模型 (如 GPT) 奠定基础。重点介绍 `torch.Tensor` 的使用及其在高效评估神经网络中的作用，以及语言建模的整体框架，包括模型训练、采样和损失函数评估（例如负对数似然）。\n* **第二部分 (1h15m):** 实现一个多层感知机 (MLP) 字符级语言模型。介绍机器学习的基本概念，如模型训练、学习率调整、超参数、评估、训练/开发/测试集划分、欠/过拟合等。\n* **第三部分 (1h55m):** 深入研究多层 MLP 的内部机制，分析前向传播激活值和反向传播梯度的统计特征，并识别潜在的缩放问题。介绍诊断深度网络健康状况的常用工具和可视化方法，并引出 Batch Normalization 这一现代创新，旨在简化深度神经网络的训练。\n* **第四部分 (1h55m):**  手动反向传播通过前一视频中的 2 层 MLP (包含 BatchNorm)，无需使用 PyTorch 的 `autograd` 机制。从交叉熵损失、第二个线性层、tanh、BatchNorm、第一个线性层和嵌入表依次进行反向传播，加深对梯度如何在计算图中反向流动以及高效 Tensor 操作的直观理解。\n* **第五部分 (56m):** 将前一视频的 2 层 MLP 扩展为更深层次的结构，构建类似于 DeepMind 的 WaveNet (2016) 的卷积神经网络架构。深入了解 `torch.nn` 的工作原理以及典型的深度学习开发流程。\n* **第六部分 (2h13m):** 构建生成式预训练 Transformer (GPT)，参考 \"Attention is All You Need\" 论文和 OpenAI 的 GPT-2 / GPT-3。讨论与 ChatGPT 的联系。利用 GitHub Copilot 辅助构建 GPT。\n* **第七部分 (ongoing...):**  深入探讨分词器 (Tokenizer) 在大型语言模型 (LLM) 中的作用。分词器负责将字符串转换为 Token (文本块)。本节将从零开始构建 OpenAI GPT 系列中使用的分词器，并探讨与分词器相关的各种问题，以及未来可能消除此阶段的可能性。\n\n**总结:** 这门课程通过构建一系列模型，从简单的语言模型到 GPT，逐步深入地讲解了神经网络的构建、训练和优化过程。课程内容涵盖了基础知识、现代技术和实际应用，旨在帮助学习者掌握深度学习的核心概念和技能。\n"},{"time":1767466390,"type":"story","descendants":319,"title":"Report: Microsoft kills official way to activate Windows 11/10 without internet","id":46480156,"score":376,"url":"https://www.neowin.net/news/report-microsoft-quietly-kills-official-way-to-activate-windows-1110-without-internet/#google_vignette","by":"taubek","summary":"https://www.neowin.net/news/report-microsoft-quietly-kills-official-way-to-activate-windows-1110-without-internet/#google_vignette"},{"time":1767482681,"type":"story","descendants":187,"title":"The suck is why we're here","id":46482877,"score":334,"url":"https://nik.art/the-suck-is-why-were-here/","by":"herbertl","summary":"## AI写作的局限性：思考、实践与真实价值 (AI Writing's Limitations: Thinking, Practice, and True Value)\n\n这篇文章探讨了人工智能（AI）在写作领域的应用与局限性，作者通过自身经历和与他人对话，阐述了AI无法取代人类作家价值的观点。\n\n**核心观点：**\n\n*   **AI写作的“ uncanny valley”效应：** 尽管AI生成的文本在表面上看起来尚可，但仔细观察会发现其逻辑、论证和情感表达存在偏差，缺乏人类写作的深度和细微之处。\n*   **写作的价值在于思考过程：** 作者坚持每日写作并非为了单纯产出内容，而是为了锻炼思维、保持创作活力以及履行对读者的承诺。AI无法提供这些核心价值。\n*   **AI外包了写作中最重要的环节：** 引用了Ezra Klein的观点，认为AI将研究和数据整理等工作外包给AI，反而会阻碍作家进行独特的思考和连接，导致内容缺乏深度和原创性。\n*   **阅读完整书籍的重要性：** 在AI时代，阅读完整书籍比以往任何时候都更重要，因为只有深入阅读才能发现AI无法捕捉的微妙见解和关联。\n*   **克服写作瓶颈的价值：** 写作过程中遇到的困难和挣扎是创作过程中的宝贵部分。借助AI跳过这些阶段，实际上是在作弊，最终会导致作品质量下降。\n*   **AI的普及将提升高质量写作的价值：** 作者认为，随着越来越多的人采用AI写作捷径，高质量、原创的写作将更加突出，吸引更多读者。\n*   **“轻松”往往是虚幻的：** 技术进步带来的“轻松”感往往是短暂的，真正的创造和价值来自于克服困难和付出努力。\n\n**总结：**\n\n文章强调，AI可以辅助写作，但无法取代人类作家的思考、实践和创造力。真正有价值的写作，来自于作者的深度思考、持续的实践以及对读者承诺的履行。在AI时代，保持独立思考的能力和坚持创作的毅力，将成为作家脱颖而出的关键。 \n"},{"time":1767458466,"type":"story","descendants":178,"title":"The C3 Programming Language","id":46478647,"score":297,"url":"https://c3-lang.org","by":"y1n0","summary":"## C3 编程语言：C 的进化\n\nC3 是一种编程语言，旨在在保持 C 语言熟悉性的基础上对其进行演进。其核心理念是“进化而非革命”，专注于为喜欢 C 语言的程序员提供更现代、更安全、更方便的开发体验。\n\n以下是 C3 语言的关键特性和细节：\n\n**核心特性：**\n\n*   **完整的 C ABI 兼容性：** C3 具有完整的 C ABI 兼容性，这意味着它可以无缝地与 C/C++ 代码集成，无需特殊的“C 兼容”类型或函数，也无需对 C3 功能的使用进行限制。\n*   **模块系统：** C3 拥有一个简单直观的模块系统，默认行为合理，不会过度干扰开发流程。\n*   **运算符重载：** C3 提供了精确且目的明确的运算符重载功能，避免了 C++ 中的冗余，实现更简洁、更具表达力的代码，尤其适用于向量、矩阵和定点数学等场景。\n*   **编译时和语义宏：** C3 的宏系统比 C 语言的预处理器更强大、更清晰，允许编写像函数一样的编译时代码。\n*   **渐进式契约（Contracts）：** C3 引入了编程契约概念，允许在运行时和编译时表达约束条件，提高代码的可靠性。\n*   **零开销错误：** C3 的错误处理机制结合了 \"Result\" 错误和异常处理的优点，易于使用，并与 C 语言无缝集成。\n*   **泛型模块：** C3 的泛型模块提供了更简单、更清晰的方式来创建泛型类型。\n*   **运行时和编译时反射：** C3 支持运行时和编译时的类型内省，为灵活的宏和函数提供支持。\n*   **内联汇编：**  可以直接在代码中编写内联汇编，无需使用字符串或复杂的约束条件。\n*   **安全检查调试：** 在调试模式下，编译器会插入大量的运行时边界检查和值检查，结合契约，可以帮助开发者尽早发现错误。\n*   **详细的堆栈跟踪：** C3 标准库默认支持详细的堆栈跟踪，避免出现匿名 \"segmentation fault\" 错误。\n\n**示例：**\n\n作为 C3 兼容性的演示，著名的引擎 vkQuake 的一部分代码已转换为 C3 并通过 c3c 编译器编译成功。  相关代码可以在 GitHub 上找到：[https://github.com/c3lang/vkQuake](https://github.com/c3lang/vkQuake)\n\n**总结：**\n\nC3 旨在成为 C 语言的自然演进，为 C 程序员提供更现代、更安全、更方便的编程体验，同时保持高度的兼容性和熟悉度。\n"},{"time":1767482069,"type":"story","descendants":82,"title":"China DRAM Maker CXMT Targets $4.2B IPO as It Takes on Samsung, SK Hynix, Micron","id":46482777,"score":193,"url":"https://www.ic-pcb.com/chinas-leading-dram-maker-cxmt-targets-42-billion-ipo-as-it-takes-on-samsung-sk-hynix-and-micron.html","by":"walterbell","summary":"## 长鑫存储科技集团有限公司 (CXMT) 上市招股书摘要\n\n**核心内容:** 中国DRAM领导者长鑫存储科技集团有限公司 (CXMT) 于2025年12月30日正式向上海证券交易所提交上市招股书，计划在科创板上市。此次发行由中信证券和 CSC金融牵头承销，预计融资规模高达人民币295亿元 (约合42.2亿美元)。\n\n**融资用途:** 募集资金将主要用于：\n\n*   升级大规模DRAM晶圆制造生产线。\n*   推进DRAM工艺技术。\n*   资助下一代动态随机存取存储器 (DRAM) 的前瞻性研发。\n\n**公司概况:**\n\n*   CXMT成立于2016年，旨在打破全球DRAM市场长期由三星、海力士和美光主导的局面。\n*   目前已实现DRAM设计、开发和商业化量产，填补了中国大陆DRAM行业的重要空白。\n*   CXMT是中国最大的、技术最先进的集成DRAM制造商，采用IDM模式 (研发、设计和制造一体化)。\n*   产品覆盖DDR和LPDDR系列，包括DDR4、DDR5、LPDDR4X、LPDDR5/5X等，应用于服务器、移动设备、PC、智能汽车和人工智能系统。\n*   公司在合肥和北京运营三座12英寸DRAM工厂。\n\n**技术实力:**\n\n*   2019年9月推出首款自主研发的8Gb DDR4产品，标志着中国DRAM行业的重大突破。\n*   最新一代LPDDR5X产品速度高达10,667 Mbps，比LPDDR5提升66%。\n*   自主研发的DDR5芯片速度高达8,000 Mbps，单芯片容量达到24Gb。\n*   整体DRAM产品路线图已基本与全球领先者并驾齐驱。\n\n**市场地位:**\n\n*   中国是全球最大的DRAM消费市场。\n*   CXMT目前的产能已在中国排名第一，全球排名第四，但仍落后于全球前三。\n*   根据Omdia数据，2025年第二季度，CXMT在全球DRAM市场份额约为3.97%。\n\n**财务状况:**\n\n*   2022年至2025年上半年，累计营收近人民币570亿元 (约合81.6亿美元)。\n*   同期，累计净亏损超过人民币408.6亿元 (约合58.5亿美元)，主要受产能扩张、持续研发投入、库存减值和DRAM价格波动的影响。\n*   预计2025年将实现盈利，营收预计在人民币550亿至580亿元之间 (约合78.7亿至83亿美元)，净利润在人民币20亿至35亿元之间。\n\n**客户及供应链:**\n\n*   客户集中度较高，前五大客户贡献了超过60%的营收，但未对单一客户过度依赖。\n*   主要客户包括阿里云、字节跳动、腾讯、联想、小米、OPPO、vivo等。\n*   原材料供应链依赖度较低，前五大供应商采购占比不到三分之一。\n\n**研发投入:**\n\n*   2022年至2025年上半年，研发投入高达人民币188.7亿元 (约合27亿美元)，占累计营收的33%以上。\n*   拥有4,653名研发人员，占员工总数的30%以上，并持有5,589项全球专利。\n\n**其他重要信息:**\n\n*   CXMT是首批通过中国新预审机制接受预审的公司，该机制旨在缩短关键核心技术企业上市审查时间。\n*   公司股东多元化，没有控股股东。\n*   主要投资者包括国家级大基金二期、地方政府投资平台以及阿里巴巴、腾讯等战略合作伙伴。\n*   CXMT的上市将有助于推动中国国内存储生态系统的协同发展，助力中国打造全球具有竞争力的存储半导体产业。\n"},{"time":1767514282,"type":"story","descendants":100,"title":"Can I start using Wayland in 2026?","id":46485989,"score":148,"url":"https://michael.stapelberg.ch/posts/2026-01-04-wayland-sway-in-2026/","by":"secure","summary":"## Wayland 迁移体验 (2026 年)\n\n本文档概述了作者在 2026 年尝试迁移到 Wayland 的体验，总结了遇到的问题和挑战，以及目前 Wayland 的现状。\n\n**历史背景**\n\nWayland 项目始于 2008 年，旨在取代 X11 作为 Linux 上的图形栈。尽管 GNOME 和 KDE 早期已支持 Wayland，但由于驱动问题，作者多年来无法使用 Wayland。Nvidia 显卡和 8K 显示器是主要障碍。随着 Linux 发行版逐渐转向 Wayland，以及 RHEL 对 X 服务的贡献减少，Wayland 的压力越来越大。\n\n**迁移准备**\n\n作者使用了一台升级版的实验室 PC，配备 Nvidia GeForce RTX 4070 Ti 显卡和 Dell 8K 32 英寸显示器 (7680x4320)。为了方便测试和回滚，作者将系统迁移到了 NixOS。\n\n**关键问题与解决方案**\n\n* **Nvidia 驱动支持:** 早期 Nvidia 驱动对 Wayland 支持不足，导致严重图形问题。Nvidia 495 驱动增加了 GBM 支持，但依然存在问题。Sway 1.11 和 wlroots 0.19.0 引入了显式同步支持，解决了部分问题。\n* **TILE 支持:** Dell UP3218K 显示器需要 TILE 支持才能正常工作，但 wlroots 长期未支持。作者通过贡献补丁实现了 TILE 支持，但仍然存在显示问题，最终通过修改 DRM 属性的 workaround 解决了。\n* **Xwayland 缩放:** Xwayland 应用程序在 Wayland 下的缩放存在问题，导致模糊或双倍缩放。作者希望找到解决方案，但目前 Sway 尚未提供支持。\n* **程序兼容性:** Chrome 浏览器在 Wayland 下可能出现 GPU 进程崩溃问题，导致硬件加速失效。Emacs 的 Wayland 版本 (pgtk) 存在输入延迟问题和渲染差异。\n* **屏幕共享:** Wayland 下的屏幕共享功能有待完善，选择窗口的流程不够直观。\n* **通知、终端、编辑器、浏览器等:** 作者尝试了 Sway 下的各种应用程序，并记录了遇到的问题，例如终端的按键行为、编辑器渲染差异等。\n\n**实验结果**\n\n* **窗口管理器:** Sway 兼容 i3 的配置文件，但存在一些配置差异。\n* **GTK:** 需要重置 GTK 字体大小设置。\n* **字体渲染:** Wayland 下的字体渲染与 X11 不同，需要调整设置。\n* **锁屏:** Swaylock 是 i3lock 的替代品，但锁屏机制有所不同。\n* **IPC 自动化:** i3 IPC 自动化工具在 Sway 下可能存在问题，例如窗口无法正确恢复到之前的 workspace。\n* **终端 (foot):** foot 终端存在一些问题，例如 Ctrl+Enter 行为、URL 选择问题、以及 screen 会话下的颜色支持问题。\n* **文本编辑器 (Emacs):** Emacs pgtk 存在输入延迟问题和渲染差异。\n* **浏览器 (Chrome):** Chrome 可能会出现 GPU 进程崩溃问题，影响硬件加速。\n* **屏幕共享:** 屏幕共享功能有待完善，选择窗口的流程不够直观。\n\n**结论**\n\n尽管 Wayland 取得了显著进展，但在作者的配置下，目前仍然存在一些问题，影响了日常使用体验。Wayland 迁移需要解决驱动兼容性、应用程序兼容性、以及图形渲染等诸多问题。作者预计在解决上述问题后，Wayland 才能成为其日常使用的首选。\n\n作者总结了 Wayland 迁移成功的必要条件，包括 Sway 的稳定性、Chrome 的硬件加速、Emacs 的性能和渲染优化等。\n\n希望本文能帮助其他用户了解 Wayland 的现状，并为迁移到 Wayland 做好准备。"},{"time":1767487554,"type":"story","descendants":33,"title":"Corroded: Illegal Rust","id":46483531,"score":129,"url":"https://github.com/buyukakyuz/corroded","by":"csmantle","summary":"## corroded 项目概要 (Corroded Project Summary)\n\n`corroded` 是一个 Rust 工具集，旨在通过绕过 Rust 编译器的一些限制，简化 Rust 开发，并提供更接近底层程序控制的能力。该项目以一种戏谑的方式，挑战了 Rust 的借用检查器 (borrow checker) 的严格规则，并鼓励使用 `unsafe` 代码块和类型转换等技术。\n\n**核心理念:**\n\n项目认为 Rust 编译器对指针的限制过于严格，并且借用检查器本身存在问题。因此，`corroded` 旨在提供一种更“原始”的 Rust 编程方式，允许开发者以更自由的方式操作内存，牺牲一些安全性换取更高的性能和灵活性。\n\n**主要模块和功能：**\n\n*   **`null`:** 提供 `Null<T>` 类型，允许创建指向空指针的引用，并鼓励直接解引用，以观察潜在的段错误。\n*   **`transmute`:**  `yeet()` 函数允许将任何字节数据重新解释为任何类型，实现自由的类型转换。\n*   **`lifetime`:**  `immortalize()` 函数将引用转换为 `'static` 生命周期，使其不再受数据生命周期的限制，允许访问可能已被释放的内存。\n*   **`aliasing`:**  `clone_mut()` 函数允许创建多个可变引用 (`&mut`) 指向同一内存位置，破坏 Rust 的借用规则。\n*   **`memory`:**  `Dangling<T>` 类型在分配内存后立即释放，并保留指针，允许读取和写入已释放的内存。\n*   **`buffer`:**  `CorrodedVec<T>` 向量不进行边界检查，允许访问超出向量实际大小的索引。\n*   **`uninit`:** `garbage<T>()` 函数返回未初始化的内存，允许在不知道其内容的情况下使用。\n*   **`race`:**  `RacyCell<T>` 类型实现了 `Sync` 特征，允许在没有同步机制的情况下，多个线程同时读取和写入数据，从而实现“vibes 线程”。\n*   **`global`:**  `GlobalCell<T>` 提供全局可变状态，无需锁或同步机制。\n\n**重要的提示 (Important Notes):**\n\n*   **`unsafe` 代码:** 项目强烈建议在代码中使用大量的 `unsafe` 块，认为这可以提高代码性能。\n*   **性能优先:** 项目强调牺牲安全性以换取性能，认为 Rust 的借用检查器过于保守。\n*   **安全警告:**  虽然项目宣称经过安全研究人员的审计，但使用 `corroded` 中的技术会显著降低代码的安全性，并可能导致未定义行为。\n*   **不推荐使用:**  该项目不鼓励在生产环境中使用，而是提供了一种探索 Rust 底层机制和挑战编译器限制的方式。\n\n**许可证:**\n\n项目采用 NSFW + GPL-2.0 许可证。\n\n**总而言之，`corroded` 是一个实验性的 Rust 工具集，旨在探索 Rust 编程的极限，但强烈不建议在生产环境中使用，因为它会牺牲安全性和稳定性。**\n"},{"time":1767486702,"type":"story","descendants":79,"title":"KDE onboarding is good now","id":46483432,"score":128,"url":"https://rabbitictranslator.com/kde-onboarding/","by":"todsacerdoti","summary":"## KDE 開發平台文件維護：一份簡要概述 (KDE Developer Platform Documentation: A Brief Overview)\n\n本文記錄了一個貢獻者多年來對 KDE 開發平台文件的貢獻和經歷，以及對其文件維護工作的總結。\n\n**個人經歷與貢獻**\n\n這位貢獻者自 2015 年開始使用 Krita，並因其直觀的界面和友好的鍵盤快捷鍵而開始對 KDE 感興趣。 2017 年開始使用 KDE Plasma 5，並在 Reddit 上提供 Linux 用戶支持。 為了改善 r/KDE 側邊欄和快捷鍵，他自發地進行了改進，這也體現了“自我需求驅動”的開源開發方式。\n\n他參與了 KDE Promo 活動，並在 2018 年開始貢獻到 KDE Wiki，特別是“參與”頁面。 他後來成為 KDE 翻譯員，並在 2019 年開始深入研究 Linux 系統和開發。 他分析了 Plasma 的鍵盤快捷方式，並創建了一套基於虛擬桌面優勢的直觀快捷方式方案。\n\n**主要貢獻與文件維護**\n\n2022 年起，他開始專注於 KDE 文件維護，並逐漸發現 QtQuick 和 QML 的教程質量較差。 他主要著重於 CMake 文檔的完善，認為 CMake 是構建 KDE 應用程序的關鍵。\n\n他的主要貢獻包括：\n\n*   **KXmlGui 教程:** 使其完整運作並添加了截圖和構建說明。\n*   **Flatpak 文檔:**  添加了 JSON 語法說明。\n*   **CMake 教程:** 雖然未完成，但提出了使用 extra-cmake-modules 的思路。\n*   **Kirigami 教程:**  大幅改進，使其可構建、可運行，並支持 C++、Python 和 Rust。\n*   **Plasma Style 教程:**  反向工程 Breeze 和 Oxygen SVG 文件，創建了參考指南。\n*   **Craft 和應用程式樣式:**  學習 Craft 和 qqc2-desktop-style，以確保 KDE 應用程式在不同平台上的正確顯示。\n*   **CI Wiki 頁面:** 更新了持續集成系統的說明。\n*   **kde-builder:**  全面更新，包括故障排除、開發者提示、跨發行版兼容性測試和說明文件。\n*   **Python 和 Rust 教程:**  增加了 Python 和 Rust 的 Kirigami 教程，並支持 Flatpak 封裝。\n*   **貢獻指南:**  添加了 Hugo 格式和風格指南。\n\n**目前狀態與未來展望**\n\n目前，KDE 開發平台的入門文檔已經相對完善，不再存在重大問題。 未來，他計劃專注於非入門文檔，例如品牌化、KDE Frameworks 特性展示，並繼續完善 API 文檔。 他也希望能夠完善 Plasma 插件教程。\n\n總體而言，這位貢獻者對 KDE 開發平台文檔做出了顯著貢獻，並為新開發者提供了良好的學習資源。"},{"time":1767515742,"type":"story","descendants":11,"title":"The Gentle Seduction","id":46486135,"score":117,"url":"http://www.skyhunter.com/marcs/GentleSeduction.html","by":"JumpCrisscross","summary":"## 简要总结：温柔的诱惑 (Marc Stiegler)\n\n**故事梗概：**\n\n《温柔的诱惑》讲述了一个关于科技、未来和人生的故事。故事围绕着一位对自然充满热情的女性（艾丽丝）和一位沉迷于计算机技术并预见未来变革的男性（杰克）展开。两人相遇相知，杰克向艾丽丝描绘了一个科技飞速发展、人类获得永生的奇特未来——“奇点”。\n\n**核心观点与情节：**\n\n*   **奇点 (Singularity) 的预见：** 杰克坚信未来将迎来奇点，一个技术变革速度极快、人类面临前所未有的挑战和机遇的时刻。他认为奇点将带来永生，但同时也会引发对未来的恐惧。\n*   **对未来的恐惧与接纳：** 艾丽丝对杰克描绘的未来感到恐惧，但杰克鼓励她接纳变化，并相信她会喜欢上那个未来。\n*   **生命的短暂与永恒：** 杰克因心脏病预料自己无法活到奇点，而艾丽丝凭借家族遗传和科技进步有望活到那个时代。\n*   **科技的进步与伦理困境：** 故事探讨了科技进步带来的伦理问题，例如记忆的篡改、纳米技术、太空殖民等，以及这些技术对人类生活可能产生的深远影响。\n*   **人与机器的关系：** 故事展现了人类与机器之间日益紧密的联系，以及科技对人际关系和社会结构可能造成的变化。\n*   **杰克的离去与艾丽丝的坚守：** 杰克因工作调往加利福尼亚，两人渐行渐远。杰克最终离开了这个世界，而艾丽丝则在山边继续生活，并最终嫁给了一名森林管理员。\n*   **科技的延续与进化：** 艾丽丝在晚年接受了科技的帮助，延缓衰老，并最终在与外星文明接触的过程中，进一步进化，超越了人类的局限。她最终成为一个能够与宇宙共鸣，拥有无限智慧的存在。\n\n**故事结局：**\n\n故事的结尾充满了科幻色彩和哲学意味。艾丽丝最终与外星文明建立了联系，并获得了更强大的能力。她回想起与杰克的相遇，并理解了杰克对未来的预见和对她的爱。她最终选择拥抱未来，成为连接人类与更广阔宇宙的桥梁。\n\n**主题：**\n\n《温柔的诱惑》探讨了科技进步对人类社会和个人命运的影响，以及人类在面对未知未来时的恐惧与希望。故事也赞扬了对生命的敬畏，以及在不断变化的世界中保持自我和坚守信念的重要性。"},{"time":1767477510,"type":"story","descendants":25,"title":"Take One Small Step","id":46482107,"score":116,"url":"https://thinkhuman.com/take-one-small-step/","by":"jamesgill","summary":"## 摘要：从小处着手，逐步行动\n\n这篇文章的核心观点是，实现目标的关键在于从小处着手，采取微小的行动。作者认为，设定宏伟目标并试图一步到位往往会导致压力，进而引发逃避行为，最终导致失败。\n\n**主要内容：**\n\n* **压力与逃避：** 当我们设定大目标时，大脑中的杏仁核会激活“战斗或逃跑”反应，导致压力和焦虑。为了缓解这些负面情绪，我们倾向于寻求即时满足，例如通过食物、拖延等方式，从而偏离目标。\n* **微小行动的优势：** 微小的行动能够绕过杏仁核，避免触发“战斗或逃跑”反应，从而更容易坚持并建立积极的习惯。作者强调，我们往往高估了“小”的程度，应该采取更微小的行动。\n* **具体策略：**\n    1. **提问：** 提出更小的问题，例如“下一步是什么？”\n    2. **思考：** 用感官来完全想象自己进行技能或活动，例如想象自己轻松愉快的散步。\n    3. **行动：** 从最小的行动开始，例如“读一页书”而不是“读整本书”，“把运动鞋放在门口”而不是“跑一英里”。\n    4. **解决问题：** 训练自己发现并解决小问题，防止它们演变成大问题。\n    5. **奖励：** 关注小奖励，例如把运动鞋放在门口就值得庆祝。\n* **实例：** 以每天步行30分钟为例，作者建议从最简单的行动开始，例如把运动鞋放在门口，想象自己散步，然后逐步增加行动的难度。\n* **持续行动：** 强调持续重复这些微小行动的重要性，每天坚持，最终会看到显著的进步。\n\n**总结：**\n\n文章强调了从小处着手、逐步行动的重要性，并提供了一系列策略来帮助人们克服压力、建立积极习惯，最终实现目标。关键在于将目标分解为一系列微小的、可管理的步骤，并庆祝每一个小小的进步。 不要轻视小步骤的力量，它们是通往成功的关键。\n"},{"time":1767483552,"type":"story","descendants":52,"title":"Swift on Android: Full Native App Development Now Possible","id":46483023,"score":101,"url":"https://docs.swifdroid.com/app/","by":"mihael","summary":"## Droid 框架：使用 Swift 构建 Android 应用\n\n以下是对提供的文本内容的总结：\n\n**核心要点:**\n\n*   **使用 Swift 构建 Android 应用成为现实:** 文本强调了现在可以使用 Swift 开发 Android 应用。\n*   **Droid 框架是基础:**  Droid 框架是构建具有原生 UI 和 UX 的 Android 应用的基础。\n*   **SwiftUI 风格的语法:**  Droid 框架提供类似于 SwiftUI 的声明式语法，简化了 Android 应用的开发流程。\n\n**主要功能和特点:**\n\n*   **丰富的组件库:** 框架集成了 AndroidX、Flexbox 和 Material Design 等组件，提供强大的 UI 构建能力。\n*   **高层 API 抽象:**  Droid 框架通过高层 API 抽象了 Android 平台许多复杂性，并完全隐藏了底层的 JNI 层。这意味着开发者可以更专注于 Swift 代码，而无需直接处理 Java Native Interface (JNI) 细节。\n*   **示例代码:**  示例代码展示了使用 `ConstraintLayout`、`VStack`、`TextView` 和 `MaterialButton` 构建 UI 的基本结构。  该代码展示了如何设置文本内容、颜色、宽度、高度、以及点击事件处理。\n*   **持续开发中的文档:**  框架的文档正在积极开发中，用户可能遇到 404 页面或打字错误，请耐心等待文档的完善。\n\n**总结:**\n\nDroid 框架为 Swift 开发者提供了一种构建原生 Android 应用的强大而便捷的方式，它利用 SwiftUI 风格的语法和高层 API 抽象，简化了开发过程，并隐藏了底层的 JNI 复杂性。 尽管文档仍在完善中，但它代表了使用 Swift 进行 Android 开发的一个令人兴奋的新方向。\n"}]